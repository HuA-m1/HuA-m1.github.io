[{"title":"DNS Spoof","url":"/2026/01/03/DNS_Spoof/","content":"# ***DNS Spoof***\n\n*摸上了**Ettercap**这款工具一直想做一下DNS劫持的,于是乎就开启了一个DNS劫持复现的过程~~~*\n\n(本演示仅用于教学,不可用于任何非法用途,违反法律造成的任何后果自行承担)\n\n\n\n**Ettercap: **    Ettercap 是一个用于局域网流量分析与中间人攻击（MITM）实验的安全工具。\n\n| 分类     | 内容               | 说明                                          |\n| -------- | ------------------ | --------------------------------------------- |\n| 工具类型 | 局域网安全测试工具 | 主要用于 **MITM（中间人）攻击实验与防御验证** |\n| 工作层级 | **二层为核心**     | 依赖 **ARP**，而不是 ping / ICMP              |\n| 使用前提 | 同一局域网         | 不同子网、跨路由基本无效                      |\n| 典型环境 | 内网 / 实验网      | Kali、教学、授权测试                          |\n\n| 功能     | 作用               | 结果                    |\n| -------- | ------------------ | ----------------------- |\n| 主机发现 | 扫描局域网在线设备 | Host List 里出现多个 IP |\n| ARP 欺骗 | 构造中间人         | 选 Target1 / Target2    |\n| 流量嗅探 | 捕获通信数据       | 能看到 HTTP / DNS       |\n| 流量篡改 | 修改经过的数据     | 演示完整性破坏          |\n| 插件系统 | 扩展攻击 / 检测    | dns_spoof、arp_cop      |\n\n接下来我就用集成了Ettercap工具的kali (linux虚拟机)来做演示:\n\n*演示前提条件 :*\n\n| 前提条件                | 是否必须 | 原因说明                          |\n| ----------------------- | -------- | --------------------------------- |\n| 同一局域网              | 必须     | DNS 劫持基于二层/三层，跨路由无效 |\n| 能成为中间人（MITM）    | 必须     | 必须“看到并拦截”DNS 请求          |\n| ARP 可被欺骗            | 必须     | 常见实现方式（Ettercap 依赖）     |\n| 目标使用 **非加密 DNS** | 必须     | DoH / DoT 会直接失效              |\n| 目标 DNS 请求能到达你   | 必须     | 不管是发给网关还是本地 DNS        |\n| 合法授权环境            | 必须     | 实验/教学前提                     |\n\n首先我们进入kali虚拟机的环境中:\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20260103163234269.png)\n\n输入对应名称就可发现相关使用的命令和功能 ; (一般多用ettercap -G图形化窗口)\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20260103163656456.png)\n\n在开始实验前,我需要做一下准备,首先需要一台受害者虚拟机(我这里是win10),保证kali与win10虚拟机可以互ping(win10防火墙全部关闭)\n\n然后查询当前win10的IP/ipconfig\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20260103164101034.png)\n\n我这里用的是桥接模式(即网关是真实存在的网关:192.168.10.1)\n\n同时需要保证二者在同一网关下.然后我们在kali上搭建自己的平台.\n\n启动apache的服务\n\n```\nservice apache2 start\n```\n\n同时进入linux的系统文件夹中,寻找配置文件(即想让受害者看到的页面),默认位置在\n\n```\n/etc/ettercap/etter.dns\n```\n\n同时对dns文件进行配置,这里添加如图两行的文本(可以理解为将所有DNS解析到对应的服务地址)\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20260103164739369.png)\n\n这里我们将DNS解析的位置定位到我们自己的IP上(即kali的IP地址),保存并退出.\n\n\n\n然后我自己简单做了一个index.html的页面来展示DNS劫持成功的结果(用trae),我们自己做了以后,放在下面的路径中.\n\n```\n/var/www/html/\n```\n\n\n\n然后我们可以自己测试一下,能否访问.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20260103170253025.png)\n\n\n\n然后我们启动ettercap图形化的工具.默认选中eth0网卡,同时关闭sniffing at startup(网络嗅探).\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20260103165015669.png)\n\n然后点击在右上角的 **√**  完成后.点击左上角的 🔍(搜索样式的图标),对该网段下的所有hosts进行扫描,再点击🔍右侧的图标\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20260103165339767.png)\n\n我们就能看到该网段下正在使用的IP.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20260103165619161.png)\n\n第一个为网段也就是路由器的地址,第二个是我另一台物理机的地址,第三个是其他物理机地址,第四个就是win10(受害)虚拟机的IP地址.\n\n我们可以用手机连接wifi重复刚才操作来观察这个表单是否改变.\n\n其次我们选中我们当前的网关作为***target1***(192.168.10.1),选中我们要劫持的主机(win10: 192.168.10.19)加入到***target2***(可以选择多个)\n\n接着我们点击MITM中间人攻击的表单,选择ARP欺骗\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20260103170406978.png)\n\n默认**OK**,然后点击右边的**三个点**,找到**plugins**选项,选择 **manage plugins**, 选择**DNS_Spoof**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20260103171409919.png)\n\n配置成功后点击左上的三角,开启劫持.此时在win10虚拟机上访问任何网站都会解析成我们之前设置的指定的页面.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20260103172104685.png)\n\n","tags":["渗透"],"categories":["Web"]},{"title":"Mode加密模式","url":"/2025/12/15/Mode加密模式/","content":"\n# ***Mode 加密模式***\n\n###### 1）是什么？\n\n1:加密模式是定义怎样通过重复利用加密算法将大于一个数据块大小的明文转化为密文。\n\n2:分组密码算法只能加密固定长度的分组，待加密的明文长度一般会大于分组长度，这里就需要对分组密码算法进行多次迭代，从而实现对明文的全部加密，迭代的方式就称为分组密码的加密模式。\n\n3:诸如Tea简单加密算法而言，在分组密码加密过程中，往往要对原明文或明文的hash摘要进行分组操作，然而加密模式所决定的其实就是分组密码加密过程中对原明文的分组过程前后进行的处理操作，这一系列的处理都是为了结合各种加密的特点来更为方便的处理，保证加密的安全。\n可以简单理解为分组模式，只不过根据不同的加密模式有不同的处理方式。\n\n###### 2）为了什么？\n\n总结为增强加密过程的安全性、灵活性和效率。\n\n###### 3）如何工作？mode加密模式的不同对解密有什么影响？\n\n这两点我们放在一起讨论学习：\n\n首先，我们知道，加密模式多种多样，是为了适合多种的加密模式。\n我们常见的加密模式有：\n\n• ECB：Electronic Code Book（电子码本模式）\n• CBC：Cipher Block Chaining（密码块链模式）\n• CTR：Counter（计数器模式）\n此外，还有其他的一些模式，本文中将不做介绍。\n• CFB：Cipher Feedback（密码反馈模式）\n• OFB：Output Feedback（输出反馈模式）等等。\n\n下面我们对每个加密模式进行分析：\n\n1. ***ECB***（电子密码本）\n\n工作原理：\nhttps://pica.zhimg.com/v2-aeb4e5a8596abdc79d564f3437f8a1f0_1440w.jpg\n\n特点：\n\n每个块独立加密，无关联性\n相同明文块生成相同密文块\n密文块按原顺序拼接\n**代码示例**（Python）：\n\n```from Crypto.Cipher import AES  \nfrom Crypto.Random import get_random_bytes\nfrom Crypto.Util.Padding import pad  \n\nkey_128 = get_random_bytes(16)  # AES-128，生成16字节的密钥\n\ndata = pad(b’SensitiveData‘, AES.block_size)  \ncipher = AES.new(key_128, AES.MODE_ECB)  \nciphertext = cipher.encrypt(data)  # 危险！禁止用于真实场景\n```\n安全警示：\n\n加密图像可见轮廓\n无法防御重放攻击\n\n\n2. ***CBC***（密码块链）\n\n工作原理：\nhttps://pica.zhimg.com/v2-b731cde78da630e4c89dacf00a49050e_1440w.jpg\n\n核心要素：\n\n初始化向量（IV）必须随机且唯一\n前一个密文块参与下一块加密\n安全配置：\n\n```from Crypto.Cipher import AES  \nimport os  \n\nkey = os.urandom(16)  \niv = os.urandom(16)  # 必须每次随机生成  \ncipher = AES.new(key, AES.MODE_CBC, iv)  \n```\n典型攻击：填充提示攻击（Padding Oracle Attack），如2014年针对SSL 3.0的POODLE攻击。\n\n\n3. ***CTR***（计数器模式）\n\n工作原理：\nhttps://pic1.zhimg.com/v2-481a22ee36fb51ab2f1fe25f3cf1fe6c_1440w.jpg\n\n优势：\n\n支持并行加密/解密\n无需填充（适合任意长度数据）\n代码实践：\n\n```from Crypto.Cipher import AES  \nimport os  \n\nkey = os.urandom(16)  \nnonce = os.urandom(8)  # 64位随机数  \ncipher = AES.new(key, AES.MODE_CTR, nonce=nonce)  \nciphertext = cipher.encrypt(b”Real-time Video Stream“)\n```\n\n\n4. ***GCM***（伽罗瓦/计数器模式）\n\n工作原理：\nhttps://pic2.zhimg.com/v2-9bbcd7679a91b69b71a6b8d3edfea30d_1440w.jpg\n\n核心价值：\n\n同时提供机密性、完整性、认证（组合了CTR加密与GMAC认证算法）\n硬件加速支持（AES-NI指令集），硬件加速效率比软件实现快10倍以上\n实战代码：\n\n```from Crypto.Cipher import AES  \nimport os  \n\nkey = os.urandom(16)  \nnonce = os.urandom(12)  \ncipher = AES.new(key, AES.MODE_GCM, nonce=nonce)  \ncipher.update(b”AdditionalData“)  # 认证附加数据  \nciphertext, tag = cipher.encrypt_and_digest(b”TopSecret“)\n```\n\n\n5. ***CCM***（计数器与CBC-MAC模式）\n\n工作原理：\nhttps://pica.zhimg.com/v2-1b7937f59d02d9220f96ab90a4496dde_1440w.jpg\n\nCCM加密模式工作原理图（RFC 3610标准兼容版）\n标签Tag：由CBC-MAC生成的认证码。\n\n适用场景：\n\n资源受限设备（如物联网传感器）\n需要轻量级认证加密的场景\n6. ***OFB***（输出反馈模式）\n\n工作原理：\nhttps://pic2.zhimg.com/v2-3ea67f3a91db15d09ed8f5e757499c97_1440w.jpg\n\n由于是将密码算法的输出反馈给密码算法，因此称为输出反馈模式。\n\n特点：\n\n密钥流预生成，抗比特翻转\n错误不会传播！\n典型应用：卫星通信\n\n7. ***CFB***（密码反馈模式）\n\n工作原理：\nhttps://pic2.zhimg.com/v2-2d145b909dd15abe1f2a4d657e78bb5b_1440w.jpg\n\n第一个块将IV加密生成密钥流，然后与明文块进行异或运算得到密文块。接下来的块会将前一个密文块作为输入来生成下一个密钥流，依次类推。\n\n因此，每个密文块不仅依赖于当前明文，还依赖于前一个密文块，这提供了自同步的能力，即使某个块在传输中出错，错误只会影响有限的后续块。\n\n核心特点：\n\n自同步：若某个密文块传输错误，错误只会影响后续有限块（取决于移位寄存器大小）。\n流加密：支持按需逐位/逐字节加密，无需等待完整数据块。\n安全注意事项：\n\nIV 必须唯一且随机，否则可能导致密钥流重复。\n避免短移位寄存器（如 CFB-8），可能降低安全性。\n认证缺失：需配合 HMAC 等机制保证完整性。\n三、选型指南\n\n\n选型指南\n\nhttps://pica.zhimg.com/v2-bbb0ed0c169d367c62d457575f64a380_1440w.jpg\n\n模式对比\n\nhttps://pic4.zhimg.com/v2-4b599408ea2c0ec898e3db3d7179368d_1440w.jpg\n记忆口诀：\n\nECB独立最危险，CBC链式IV关键；\n\nCTR流转性能先，GCM认证最安全；\n\nOFB预载抗错链，CFB自同步有限传；\n\nCCM轻量物联选，按需配置避风险。\n\n四、实战：OpenSSL性能测试\n\n1. 速度测试命令\n\n### 测试AES-128-GCM性能  \nopenssl speed -evp aes-128-gcm  \n\n### 对比所有模式  \nfor mode in ecb cbc ctr ofb cfb gcm ccm; do  \n    openssl speed -evp aes-128-$mode  \ndone  \n2. 典型结果（i7-12700H）\n\n模式\t速度（MB/s）\nECB\t498\nCBC\t432\nCTR\t460\nGCM\t415\nCCM\t385\n五、安全加固检查清单\n\n1. 通用原则\n\n禁用ECB：openssl ciphers -v '!ECDHE-RSA-AES256-SHA:!AES256-ECB'\n强制前向保密：优先选择ECDHE密钥交换\n定期轮换密钥：尤其是长期使用的对称密钥\n2. 各模式专用配置\n\nCBC：启用PKCS#7填充校验\nGCM：确保nonce全局唯一（推荐计数器）\nCTR：使用64位随机nonce+64位计数器\n六、总结：加密模式的进化之路\n\n从ECB到GCM，加密模式的演进史就是一部对抗黑客攻击的历史：\n\n第一代：ECB/CBC（基础防护）\n第二代：CTR/OFB/CFB（性能优化）\n第三代：GCM/CCM（认证加密）\n未来趋势：\n\n抗量子加密：CRYSTALS-Kyber等算法整合\n内存安全实现：Rust语言重构OpenSSL\n通过本文，相信你已掌握七种加密模式的本质差异与实战要点。记住：没有绝对安全的算法，只有正确场景下的合理选择。\n\n立即行动：\n\n使用nmap --script ssl-enum-ciphers扫描你的服务器，欢迎评论区分享扫描出的安全评级结果，获取定制化加固建议！\n\nNmap扫描结果中密码套件强度分级（本例为A，采用了GCM模式）\n\nhttps://pic4.zhimg.com/v2-0a8a8546083ae1317481ba5631051705_1440w.jpg\n\n上述部分来源Source：https://zhuanlan.zhihu.com/p/1906102542502466994\n\n","tags":["Basics"],"categories":["Crypto"]},{"title":"IV（Initialization Vector）——初始化向量","url":"/2025/12/15/IV初始化向量/","content":"\n# ***IV（Initialization Vector）——初始化向量***\n\n本文简单阐述IV初始化向量的意义。\n\n###### 什么是IV？\n\n顾名思义，初始化：一开始就需要被使用的。\n\n定义：\nIV是在密码学中为增强安全性而引入的一个随机或伪随机数据块，通常与分组密码的某些工作模式（如 CBC、CFB、OFB、CTR 等）配合使用。#具体应用可以看看mode加密模式那一篇。\n\n###### 干什么的？\n\n作用（存在意义）：\n\nIV 是在加密算法开始时使用的 初始输入值，其主要作用是保证即使相同的密钥和相同的明文重复出现，最终产生的密文也不会一样，从而防止攻击者通过分析重复模式推测信息。\n\n*Personal opinion*：我们在mode加密模式那章见过IV，以及可能在CTF比赛中对于AES解密过程中可能需要我们发现IV并填充以正确解密。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251216145705449.png)\n\nhttps://pica.zhimg.com/80/v2-01a89d098bf3daf5a1e41cdea573708a_1440w.webp?source=1def8aca\n\n\n总的来说，IV可以在分组密码mode模式下，与明文块1或加密后的密文块1进行异或等操作后再进行之后一系列的分组加密操作，以保证随机性和唯一性。（可以类比加盐这一操作的意义）\n\n（关于加盐和IV的区别会在另一文章中阐述，以便更好的理解各自的实际意义和作用，工作原理）\n","tags":["Basics"],"categories":["Crypto"]},{"title":"ECDSA","url":"/2025/12/15/ECDSA/","content":"\n# ***ECDSA***\n\n@2025年11月6日\n\nECDSA主要包含两个过程部分：\n1:签名\n2:验签\n\n1）ECDSA的签名过程包括以下步骤：\n\n选择一条椭圆曲线Ep（a，b）和基点G；\n选择私有密钥k（k<n，n为G的阶），利用基点G计算公开密钥K=kG；\n产生一个随机整数r（r<n），计算点R=rG；\n将原数据和点R的坐标值x，y作为参数，计算SHA1做为hash，即Hash=SHA1（原数据，x，y）；\n计算s≡r−Hash∗k(modn)；\nr和s做为签名值，如果r和s其中一个为0，重新从第3步开始执行。\n验证过程如下：\n\n2）接受方在收到消息m和签名值r，s后，进行以下运算；\n计算sG+H(m)P=(x1，y1)，r1≡x1modp；\n验证等式：r1≡rmodp；\n如果等式成立，接受签名，否则签名无效。\n\n***大致过程如上所述，那么如何实现的呢？***\n\n学习前，可能会有这样的疑问：椭圆曲线如何选择，公私钥如何生成，一般对什么样的消息进行签名，最终签名如何生成。。。。。。\n\n\n首先，选定椭圆方程。一般情况下选择： y^{2}=x^{3}+ax+b   形式的方程。\n\n确定G点基点（G点是椭圆曲线上预先选定的一个点，是整个 ECDSA 算法运算的起始点）\n\n曲线的阶（(n)）是指椭圆曲线上所有点（包括无穷远点）的数量。\n\n私钥<u>***private key***</u>选取：D随机数（1<=D<=n-1）。\n\n公钥<u>***public key***</u>生成根据私钥Q：Q=D*G\n\n待加密数据消息：M———M被hash(m),m的hash值作为后续处理的明文。\n\n产生一个随机整数r（r<n）。\n\n同样  R= r*G， R用于后续另一个hash数的生成，hash数后续再用于s的产生。（注：***签名的产生始终以（r,s)的形式产生，其目的始终是为了通过复杂的变化和计算来完成签名的安全性，无需深究逻辑***）\n\n再之，将原始数据和点R的坐标值x，y作为参数，计算SHA1做为hash，即Hash=SHA1（原数据，x，y）；\n\n***那么为何如果r和s其中一个为0，重新从第3步开始执行呢？***\n\n一般情况下，从安全角度看，r 或 s 为 0 可能会泄露私钥的信息或者使签名容易受到攻击。正常的签名过程是通过私钥和随机数生成的，而 r 或 s 为 0 可能暗示随机数的选取出现了问题，或者私钥的使用存在漏洞，这会严重威胁安全。\n\n以下是AI给出的回答，这里以图片形式供作参考：\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251216145004766.jpg)\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251216145048853.jpg)\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251216145121657.jpg)\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251216145152783.jpg)\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251216145221053.jpg)\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251216145236612.jpg)\n\nWanBi!\n接下来，通过一个python代码，来展示ECDSA的实际应用过程：\n\n```from ecdsa import SigningKey, SECP256k1\nimport hashlib\n\n# 1. 生成私钥和公钥\nsk = SigningKey.generate(curve=SECP256k1)\nvk = sk.verifying_key\n\nmessage = b”Hello, ECDSA!“\ne = hashlib.sha256(message).digest()\n\n# 2. 生成签名\nsignature = sk.sign(e)\n\n# 3. 验证签名\nis_valid = vk.verify(signature, e)\nprint(”验证结果：“, is_valid)\n```\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Basics"],"categories":["Crypto"]},{"title":"RC4","url":"/2025/12/15/RC4/","content":"\n# ***RC4***\n\n什么是RC4 ?\nRC4加密算法是大名鼎鼎的RSA三人组中的头号人物Ron Rivest在1987年设计的密钥长度可变的流加密算法簇，之所以称其为簇，是由于其核心部分的S-box长度可为任意，但一般为256字节。\n\n在密码学中，RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。所谓对称加密，就是加密和解密的过程是一样的。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。\n\nRC4已经成为一些常用的协议和标准的一部分，如1997年的WEP和2003/2004年无线卡的WPA; 和1995年的SSL，以及后来1999年的TLS。让它如此广泛分布和使用的主要因素是它不可思议的简单和速度，不管是软件还是硬件，实现起来都十分容易。\n\n基本原理\n对明文使用同一个密钥异或两次最后得到的是原文\n\n加密：原文和Keystream进行异或得到密文\n解密：密文和Keystream进行异或得到原文\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251216145513358.png)\n\n\n\n生成秘钥流（KeyStream）\n从上图可以看出来，RC4加密原理很简单，只需要一个KeyStream与明文进行异或即可，密钥流的长度和明文的长度是对应的。RC4算法的的主要代码还是在于如何生成秘钥流。\n\n密钥流的生成由两部分组成：\n\nKSA（the Key-Scheduling Algorithm)\nPRGA(the Pseudo-Random Generation Algorithm)\n利用Key生成S盒——The key-scheduling algorithm (KSA)\n\n```/* 得到S-box */\nint i = 0;\nfor (i = 0; i < 256; i++) {\n    S[i] = i;\n    T[i] = puc_key[i % key_length];\n}\n \nfor (i = 0; i < 256; i++) {\n    j = (j + S[i] + T[i]) % 256;\n    swap_uchar(&S[i], &S[j]); //交换S[i]和S[j]\n}\n```\n利用S盒生成密钥流——The pseudo-random generation algorithm(PRGA)\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251216145512436.png)\n\n\n图片来源：https://www.biaodianfu.com/rc4.html\n\n/* 生成密钥流 Keystream */\n```int i = 0;\nint j = 0;\nint t = 0;\nunsigned long k = 0;\n \nfor (k = 0; k < ul_data_length; k++) {\n    i = (i + 1) % 256;\n    j = (j + puc_sbox[i]) % 256;\n    swap_uchar(&puc_sbox[i], &puc_sbox[j]);\n    t = (puc_sbox[i] + puc_sbox[j]) % 256;\n    puc_key_stream[k] = puc_sbox[t];\n}\n\n代码实现\n#include<stdio.h>\n#include<string.h>\n \n#define SBOX_LEN 256\n \n#define rc4_encrypt rc4_crypt\n#define rc4_decrypt rc4_crypt\n \nstatic inline void swap_uchar(unsigned char *puc_x, unsigned char *puc_y)\n{\n    *puc_x = *puc_x ^ *puc_y;\n    *puc_y = *puc_x ^ *puc_y;\n    *puc_x = *puc_x ^ *puc_y;\n}\n \nvoid hexdump(unsigned char *puc_data, int length)\n{\n    int i = 0;\n \n    for (i = 0; i < length; i++) {\n        printf(\"%02X\", puc_data[i]);\n        if (i && (i + 1) % 16 == 0) {\n            putchar('\\n');\n        }\n    }\n    printf(\"\\n\");\n}\n \n/**\n * 利用Key生成S盒\n * the Key-Scheduling Algorithm\n */\nstatic void rc4_ksa(unsigned char *puc_sbox, unsigned char *puc_key, int key_length)\n{\n    int i = 0;\n    int j = 0;\n    char tmp[SBOX_LEN] = {0};\n \n    for (i = 0; i < SBOX_LEN; i++) {\n        puc_sbox[i] = i;\n        tmp[i] = puc_key[i % key_length];\n    }\n \n    for (i = 0; i < SBOX_LEN; i++) {\n        j = (j + puc_sbox[i] + tmp[i]) % SBOX_LEN;\n        swap_uchar(&puc_sbox[i], &puc_sbox[j]); //交换puc_sbox[i]和puc_sbox[j]\n    }\n}\n \n/**\n * 利用S盒生成密钥流\n * The pseudo-random generation algorithm(PRGA)\n */\nstatic void rc4_prga(unsigned char *puc_sbox, unsigned char *puc_key_stream, unsigned long ul_data_length)\n{\n    int i = 0;\n    int j = 0;\n    int t = 0;\n    unsigned long k = 0;\n \n    for (k = 0; k < ul_data_length; k++) {\n        i = (i + 1) % SBOX_LEN;\n        j = (j + puc_sbox[i]) % SBOX_LEN;\n        swap_uchar(&puc_sbox[i], &puc_sbox[j]);\n        t = (puc_sbox[i] + puc_sbox[j]) % SBOX_LEN;\n        /* 为了更清晰理解rc4算法流程，此处保存keystream，不直接进行XOR运算 */\n        puc_key_stream[k] = puc_sbox[t];\n    }\n}\n \n/* 加解密 */\nvoid rc4_crypt(unsigned char *puc_data, unsigned char *puc_key_stream, unsigned long ul_data_length)\n{\n    unsigned long i = 0;\n \n    /* 把PRGA算法放在加解密函数中可以不需要保存keystream */\n    for (i = 0; i < ul_data_length; i++) {\n        puc_data[i] ^= puc_key_stream[i];\n    }\n}\n \nint main(int argc, char *argv[])\n{\n    unsigned char sbox[SBOX_LEN] = {0};\n    char key[SBOX_LEN] = {\"abcdefghijklmnopqrstuvwxyz\"}; //秘钥内容随便定义\n    char data[512] = \"lsRJ@.0 lvfvr#9527\";\n    unsigned char puc_keystream[512] = {0};\n    unsigned long ul_data_length = strlen(data);\n \n    printf(\"key=%s, length=%d\\n\\n\", key, strlen(key));\n    printf(\"Raw data string:%s\\n\", data);\n    printf(\"Raw data hex:\\n\");\n    hexdump(data, ul_data_length);\n \n    /* 生成S-box */\n    rc4_ksa(sbox, (unsigned char *)key, strlen(key));\n \n    /* 生成keystream并保存,S-box也会被更改 */\n    rc4_prga(sbox, puc_keystream, ul_data_length);\n \n    printf(\"S-box final status:\\n\");\n    hexdump(sbox, sizeof(sbox));\n \n    printf(\"key stream:\\n\");\n    hexdump(puc_keystream, ul_data_length);\n \n    /* 加密 */\n    rc4_encrypt((unsigned char*)data, puc_keystream, ul_data_length);\n \n    printf(\"cipher hexdump:\\n\");\n    hexdump(data, ul_data_length);\n \n    /* 解密 */\n    rc4_decrypt((unsigned char*)data, puc_keystream, ul_data_length);\n \n    printf(\"decypt data:%s\\n\", data);\n \n    return 0;\n}\n","tags":["Basics"],"categories":["Crypto"]},{"title":"Padding填充模式","url":"/2025/12/15/padding模式/","content":"\n# ***Padding填充模式***\n\nPadding（填充）是指在执行分组加密时，为了让明文长度刚好符合“分组大小的整数倍”，在明文末尾增加一些额外字节的过程。\n\n我们在初次接触密码算法的过程中，使用一些专业的密码破解工具时往往能看到某些加密的过程中会有像PCKS#7等等的模式选项，经过查询我们可以得知这是一种密码在加密过程中对明文不满足特定长度倍数的一种特殊处理方法，以便更为快速方便的加密更为多样的明文消息。\n\n#### 举例：\nTEA、DES 的 block size = 8 字节\nAES 的 block size = 16 字节\n如果明文长度不是 8 或 16 的整数倍，就必须“填满”这一块，才能加密。\n\n### 为什么需要 Padding（填充）？\n\n分组加密算法（Block Cipher）有一个不可改变的特点：\n它只能处理固定长度的分组（block）\n例如 TEA 一次只能处理 64 bit（8 字节）。\n如果明文是：\nHELLO (5 字节)\n\nTEA 不能直接加密，因为 5 ≠ 8。\n必须变成 8 字节，例如：\n48 45 4C 4C 4F 03 03 03   ← PKCS#7 填充\n\n于是 TEA 才能加密一个完整的 block。\n\n因此我们在解密的过程中需要对padding填充模式进行选择以此来正确进行解密过程。\n\n#### 那么padding模式有哪些？这些具有哪些的特点？不同的分组密码一般选择什么padding模式呢？\n\n### **填充模式**\n##### NoPadding\n不填充，在此填充下原始数据必须是分组大小的整数倍，非整数倍时无法使用该模式，会报错。\n###### PKCS5Padding / PKCS7Padding\n填充至符合块大小的整数倍，填充值为填充数量数，需要填充7个字节，就全部填07。\n\n原始：FF FF FF FF FF FF FF FF FF\n填充：FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07\n\nPKCS5Padding 的块大小应为 8 个字节，而 PKCS7Padding 的块大小可以在 1~255 的范围内。但 SunJCE 的 Provider 实现中 PKCS5Padding 也按 PKCS7Padding 来进行处理了。\n有个细节，如果明文刚好是块的整数倍，也要加填充。\n###### ISO10126Padding\n填充至符合块大小的整数倍，填充值最后一个字节为填充的数量数，其他字节随机处理。\n\n原始：FF FF FF FF FF FF FF FF FF\n填充：FF FF FF FF FF FF FF FF FF 3F 7A B4 09 14 36 07\n\n###### ISO7816-4Padding\n填充至符合块大小的整数倍，填充值第一个字节为 0x80，其他字节填 0。\n\n原始：FF FF FF FF FF FF FF FF FF\n填充：FF FF FF FF FF FF FF FF FF 80 00 00 00 00 00 00\n\n###### ZeroBytePadding\n填充至符合块大小的整数倍，填充值为 0\n\n原始：FF FF FF FF FF FF FF FF FF\n填充：FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00\n\n###### X923Padding\n填充至符合块大小的整数倍，填充值最后一个字节为填充的数量数，其他字节填 0。\n\n原始：FF FF FF FF FF FF FF FF FF\n填充：FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 07\n\n###### TBCPadding（Trailing-Bit-Compliment）\n填充至符合块大小的整数倍，原文最后一位为“1”时填充 0x00，最后一位为“0”时填充“0xFF”。\n\n原始：FF FF FF FF FF FF FF FF FF\n填充：FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00\n原始：FF FF FF FF FF FF FF FF F0\n填充：FF FF FF FF FF FF FF FF F0 FF FF FF FF FF FF FF\n\n###### PKCS1Padding\n该填充模式是 RSA 加密中使用的，详见 RFC 2313。RSA 加密时，需要将原文填充至密钥大小，填充的格式为：\n00 + BT + PS + 00 + D\n\n00 为固定字节\nBT 为处理模式。公钥操作时为 02，私钥操作为 00 或 01\nPS 为填充字节，填充数量为 k - 3 - D，k 表示密钥长度，D 表示原文长度。PS 的最小长度为 8 个字节。填充的值根据 BT 值不同而不同：\n\n\nBT = 00 时，填充全 00\nBT = 01 时，填充全 FF\nBT = 02 时，随机填充，但不能为 00\n\n***Source***[：https://juejin.cn/post/7410347333646417946](https://juejin.cn/post/7410347333646417946)\n","tags":["Basics"],"categories":["Crypto"]},{"title":"xxtea","url":"/2025/12/15/xxtea/","content":"\n# ***xxtea***\n\n那么xxtea又来了！\n\n相比于xtea，乃至tea，这次的改进可谓是大改进，在安全性和加密流程上做了较为巨大的改动，整体安全性也得到了提升：\n1、处理任意长度数据\n2、增强扩散性和抗差分攻击能力\n3、key调度更合理\n\n观察tea和xtea，不难发现其实改动并不大，而且分组明文块的大小始终固定为八字节难免会存在安全性问题。 包括xtea和tea只在一个块中的两个半块进行扩散等等。\n\nXXTEA = XTEA 的多块版本 + 非线性轮函数改进 + 轮数随数组长度调整 + 修复 Block TEA 弱点\nxxtea采用相邻半块进行更新，而tea，xtea只在一个块中的两个半块更新：\n\n```\nv[i] = v[i] + F( v[i-1], v[(i+1)%n], sum, K[i&3] )\n```\n\n\n## ***下面从5个方面来看看区别：***\n#### ***存在意义***\n\n| 算法    | 目标                                             |\n| ----- | ---------------------------------------------- |\n| XTEA  | 修复 TEA 的弱点（等价密钥问题、周期性问题），适用于固定 64-bit 分组加密     |\n| XXTEA | 扩展 XTEA，支持任意长度数据块，修复原 Block TEA 的弱点，提高多块消息的安全性 |\n\n\n\n#### ***数据块结构***\n\n| 特性   | XTEA                        | XXTEA                 |\n| ---- | --------------------------- | --------------------- |\n| 分组大小 | 64-bit（v0, v1 两个 32-bit 半块） | 任意长度数组 ≥2 个 32-bit 单元 |\n| 数据处理 | 只处理两个半块                     | 循环处理整个数组，每块受邻居影响      |\n\n\n#### ***轮函数与数据扩散***\n\n| 特性    | XTEA          | XXTEA                |\n| ----- | ------------- | -------------------- |\n| 每轮更新  | v0 或 v1 交替    | 每块 v[i] 更新，受左右邻居影响   |\n| 数据扩散  | 限于两个半块之间      | 整个数组，扩散性强            |\n| 轮数    | 固定 64         | 随数组长度 n 调整（6 + 52/n） |\n| 非线性组合 | 移位 + 加法 + XOR | 移位 + XOR + 加法 + 邻居影响 |\n\n\n\n#### ***key调度***\n\n| 特性           | XTEA                           | XXTEA                |\n| ------------ | ------------------------------ | -------------------- |\n| key_index 来源 | sum 的 bit：(sum&3, (sum>>11)&3) | 块索引 i & 3            |\n| key 使用规律     | 随轮数 sum 决定，跳跃式但依赖 sum          | 直接依赖块索引，循环全数组，更简单且安全 |\n| key 与数据块关联   | 仅两个半块                          | 所有块都用 key 参与更新       |\n\n\n\n#### ***安全性对比***\n\n| 特性    | XTEA                 | XXTEA                          |\n| ----- | -------------------- | ------------------------------ |\n| 弱点修复  | 修复 TEA 的等价密钥问题和周期性弱点 | 修复 Block TEA 多块弱点，增强扩散和抗差分攻击能力 |\n| 抗差分攻击 | 有限扩散，攻击难度比 TEA 高     | 扩散性强，攻击难度更大                    |\n| 适用场景  | 小分组、嵌入式              | 任意长度消息，多块数据加密                  |\n\n\n\n\n### ***总结：***\n1. **XTEA** = TEA 改进版，固定 64-bit 分组，key 由 sum 决定，轮数固定。\n2. **XXTEA** = XTEA 的多块扩展版，可加密任意长度数组，轮函数覆盖全数组，每块受邻居影响，key 由块索引决定，扩散性更强。\n","tags":["Basics"],"categories":["Crypto"]},{"title":"Tea","url":"/2025/12/15/Tea/","content":"\n# ***Tea***\n\n（*Tiny Encryption Algorithm*）｜分组加密算法\n\nBasic Elements：\n\n| 参数 | 说明                                  |\n| -- | ----------------------------------- |\n| 明文 | 64 比特（分为两个 32 位部分）                  |\n| 密钥 | 128 比特（分为 4 个 32 位部分）               |\n| 轮数 | 64 次（32 轮循环，每轮包含两个半轮操作）             |\n| 常量 | `delta = 0x9E3779B9` （即黄金分割常数的整数近似） |\n\n首先，我们逐一对各个***element***进行分析解释：\n\n###### 明文：\n\n明文长度不一定是64bit\n明文不是 64 位（不是 8 字节）怎么办？——***必须填充（padding）到 8 字节的倍数***。\n填充完之后再做处理。\n\n###### 分组：\n\n明文填充（padding）到 8 字节的倍数需要分组。\nexample：\n“helloctfgaoshou”，此字符串按照utf-8编码，标准的ASCII字符串的长度是15，很显然需要填充一个字符来达到8字节整数倍达到16字节。\n\n此处按PKCS7Padding模式，按块所缺个数填充值。\n例如：填充至符合块大小的整数倍，填充值为填充数量数，需要填充7个字节，就全部填07。\n\n原始：FF FF FF FF FF FF FF FF FF\n填充：FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07\n\n填充完之后进行分组，按每**8**字节为一个**块（block）**。\n\nBlock 0: 前 8 字节\nBlock 1: 后 8 字节\n\n接着每个块（即每8个字节）：\n\n每 8 字节被分成：\nv0 = 前 4 字节（32bit） // 1字节==8位（bit）\nv1 = 后 4 字节（32bit）\n\n这样分组工作就做好了！\n\n再之我们就需要进行加密工作了，但在这之前我们需要选取一个合适的key。\n\n###### 选取key：\n\nkey的选取不是随机的，当然也是随机的。\n\n为什么这么说呢，前者是说key的选取要有一定的要求：\n\n1、必须是 16 字节（128 位） //！注意：key一般不推荐进行填充！\n2、任意字节值都可以（00–FF）\n3、可以是字符串、随机数、固定常量都行\n（但字符串本身也必须恰好 16 字节）\n\n后者对key就要有随机性，不能有特殊含义和规律。\n\n\n###### 加密：\n\n加密按每4字节进行（前面已经分好组了）。\n同时key也要进行**分组**，在**分组**那边就不多赘述了，直接在这里讲。\n\n将 key 拆成 4 个 32-bit 整数。\n明文8字节一组，每组独立加密。\n每组执行 32 轮运算：（以下是示例代码）\n```DELTA = 0x9E3779B9\nsum = 0\n\nfor i = 1 to 32:\n    sum += DELTA\n    v0 += ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1) //kn为分组后key\n    v1 += ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3) //vn为分组后明文\n```\n当然如果太明白这段代码，可以看一下文字赘述，或者AI辅助理解：\n\n###### v0 += ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1)\n逐项拆解：\n(v1 << 4) + k0\nv1 左移 4 位 → 放大高位信息\n加上子密钥 k0 → 加入密钥扰动\n左移 4 位相当于乘 16，加大 v1 对 v0 的影响\n(v1 + sum)\n用 v1 + 累加的 sum 做混合\nsum 每轮不同，保证每轮输入不同\n(v1 >> 5) + k1\nv1 右移 5 位 → 保留低位信息\n加上子密钥 k1 → 密钥扰动\n左移和右移结合，增强高低位混合\n三者用异或 ^ 连接\nXOR 可以把各部分位信息混合\n保证混合后 v0 每轮高度变化\n最后 v0 += …\n将混合结果加到 v0\n所有操作都是 32-bit 无符号整数，溢出会自动循环\n###### v1 += ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3)\n和 v0 的更新几乎一样，只是用新的 v0 和 k2/k3\n保证左右交互（Feistel结构）：\nv0 影响 v1\nv1 影响下一轮 v0\n\n最后学习了这些，给给大家一个完整的加解密流程，来深入感受Tea。\n\n###### 加密：\n\n```#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define DELTA 0x9E3779B9\n#define ROUNDS 32\n\n// —————————\n// TEA 单组加密（v0,v1）\n// key: 16 字节\n// —————————\nvoid tea_encrypt_block(uint32_t *v, uint32_t *k) {\n    uint32_t v0 = v[0], v1 = v[1];\n    uint32_t sum = 0;\n\n    for (int i = 0; i < ROUNDS; i++) {\n        sum += DELTA;\n        v0 += ((v1 << 4) + k[0]) ^ (v1 + sum) ^ ((v1 >> 5) + k[1]);\n        v1 += ((v0 << 4) + k[2]) ^ (v0 + sum) ^ ((v0 >> 5) + k[3]);\n    }\n\n    v[0] = v0;\n    v[1] = v1;\n}\n\n// —————————\n// 对任意长度明文进行 TEA 加密\n// —————————\nvoid tea_encrypt(uint8_t *plaintext, int len, uint8_t *key, uint8_t **ciphertext, int *cipher_len) {\n    // 填充到 8 字节倍数\n    int pad_len = 8 - (len % 8);\n    if (pad_len == 0) pad_len = 8;\n\n    int total_len = len + pad_len;\n    uint8_t *buf = (uint8_t *)malloc(total_len);\n    memcpy(buf, plaintext, len);\n\n    // PKCS7 填充\n    for (int i = len; i < total_len; i++) {\n        buf[i] = pad_len;\n    }\n\n    *cipher_len = total_len;\n    *ciphertext = (uint8_t *)malloc(total_len);\n\n    // 将 key 拆成 4 个 32-bit\n    uint32_t k[4];\n    for (int i = 0; i < 4; i++) {\n        k[i] = ((uint32_t)key[i*4] << 24) | ((uint32_t)key[i*4 + 1] << 16)\n             | ((uint32_t)key[i*4 + 2] << 8) | ((uint32_t)key[i*4 + 3]);\n    }\n\n    // 每 8 字节分组加密\n    for (int i = 0; i < total_len; i += 8) {\n        uint32_t v[2];\n        v[0] = ((uint32_t)buf[i] << 24) | ((uint32_t)buf[i+1] << 16)\n             | ((uint32_t)buf[i+2] << 8) | ((uint32_t)buf[i+3]);\n        v[1] = ((uint32_t)buf[i+4] << 24) | ((uint32_t)buf[i+5] << 16)\n             | ((uint32_t)buf[i+6] << 8) | ((uint32_t)buf[i+7]);\n\n        tea_encrypt_block(v, k);\n\n        // 存回密文\n        (*ciphertext)[i]   = (v[0] >> 24) & 0xFF;\n        (*ciphertext)[i+1] = (v[0] >> 16) & 0xFF;\n        (*ciphertext)[i+2] = (v[0] >> 8) & 0xFF;\n        (*ciphertext)[i+3] = v[0] & 0xFF;\n\n        (*ciphertext)[i+4] = (v[1] >> 24) & 0xFF;\n        (*ciphertext)[i+5] = (v[1] >> 16) & 0xFF;\n        (*ciphertext)[i+6] = (v[1] >> 8) & 0xFF;\n        (*ciphertext)[i+7] = v[1] & 0xFF;\n    }\n\n    free(buf);\n}\n\n// —————————\n// 测试 TEA 加密\n// —————————\nint main() {\n    uint8_t key[16] = ”1234567890abcdef“;  // 16 字节 key\n    uint8_t plaintext[] = ”woshinibaba“;    // 明文\n    uint8_t *ciphertext;\n    int cipher_len;\n\n    tea_encrypt(plaintext, strlen((char *)plaintext), key, &ciphertext, &cipher_len);\n\n    printf(”密文 (HEX): “);\n    for (int i = 0; i < cipher_len; i++) {\n        printf(”%02X “, ciphertext[i]);\n    }\n    printf(”\\n“);\n\n    free(ciphertext);\n    return 0;\n}\n```\n\n###### 解密：\n\n```#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define DELTA 0x9E3779B9\n#define ROUNDS 32\n\n// —————————\n// TEA 单组解密（v0,v1）\n// key: 16 字节\n// —————————\nvoid tea_decrypt_block(uint32_t *v, uint32_t *k) {\n    uint32_t v0 = v[0], v1 = v[1];\n    uint32_t sum = DELTA * ROUNDS;  // 解密从最大 sum 开始\n\n    for (int i = 0; i < ROUNDS; i++) {\n        v1 -= ((v0 << 4) + k[2]) ^ (v0 + sum) ^ ((v0 >> 5) + k[3]);\n        v0 -= ((v1 << 4) + k[0]) ^ (v1 + sum) ^ ((v1 >> 5) + k[1]);\n        sum -= DELTA;\n    }\n\n    v[0] = v0;\n    v[1] = v1;\n}\n\n// —————————\n// 对任意长度密文进行 TEA 解密\n// —————————\nvoid tea_decrypt(uint8_t *ciphertext, int cipher_len, uint8_t *key, uint8_t **plaintext, int *plain_len) {\n    if (cipher_len % 8 != 0) {\n        printf(”密文长度必须是 8 的倍数\\n“);\n        *plaintext = NULL;\n        *plain_len = 0;\n        return;\n    }\n\n    uint8_t *buf = (uint8_t *)malloc(cipher_len);\n\n    // 将 key 拆成 4 个 32-bit\n    uint32_t k[4];\n    for (int i = 0; i < 4; i++) {\n        k[i] = ((uint32_t)key[i*4] << 24) | ((uint32_t)key[i*4 + 1] << 16)\n             | ((uint32_t)key[i*4 + 2] << 8) | ((uint32_t)key[i*4 + 3]);\n    }\n\n    // 每 8 字节分组解密\n    for (int i = 0; i < cipher_len; i += 8) {\n        uint32_t v[2];\n        v[0] = ((uint32_t)ciphertext[i] << 24) | ((uint32_t)ciphertext[i+1] << 16)\n             | ((uint32_t)ciphertext[i+2] << 8) | ((uint32_t)ciphertext[i+3]);\n        v[1] = ((uint32_t)ciphertext[i+4] << 24) | ((uint32_t)ciphertext[i+5] << 16)\n             | ((uint32_t)ciphertext[i+6] << 8) | ((uint32_t)ciphertext[i+7]);\n\n        tea_decrypt_block(v, k);\n\n        // 存回明文\n        buf[i]   = (v[0] >> 24) & 0xFF;\n        buf[i+1] = (v[0] >> 16) & 0xFF;\n        buf[i+2] = (v[0] >> 8) & 0xFF;\n        buf[i+3] = v[0] & 0xFF;\n\n        buf[i+4] = (v[1] >> 24) & 0xFF;\n        buf[i+5] = (v[1] >> 16) & 0xFF;\n        buf[i+6] = (v[1] >> 8) & 0xFF;\n        buf[i+7] = v[1] & 0xFF;\n    }\n\n    // 去掉 PKCS7 填充\n    int pad_len = buf[cipher_len - 1];\n    if (pad_len <= 0 || pad_len > 8) pad_len = 0;  // 异常情况\n    *plain_len = cipher_len - pad_len;\n\n    *plaintext = (uint8_t *)malloc(*plain_len + 1);\n    memcpy(*plaintext, buf, *plain_len);\n    (*plaintext)[*plain_len] = ’\\0‘;  // 末尾加 ’\\0‘\n\n    free(buf);\n}\n\n// —————————\n// 测试 TEA 加解密\n// —————————\nint main() {\n    uint8_t key[16] = ”1234567890abcdef“;  // 16 字节 key\n    uint8_t plaintext[] = ”woshinibaba“;    // 明文\n\n    uint8_t *ciphertext;\n    int cipher_len;\n\n    // 加密\n    tea_encrypt(plaintext, strlen((char *)plaintext), key, &ciphertext, &cipher_len);\n\n    printf(”密文 (HEX): “);\n    for (int i = 0; i < cipher_len; i++) {\n        printf(”%02X “, ciphertext[i]);\n    }\n    printf(”\\n“);\n\n    // 解密\n    uint8_t *decrypted;\n    int decrypted_len;\n\n    tea_decrypt(ciphertext, cipher_len, key, &decrypted, &decrypted_len);\n    printf(”解密结果: %s\\n“, decrypted);\n\n    free(ciphertext);\n    free(decrypted);\n    return 0;\n}\n```","tags":["Basics"],"categories":["Crypto"]},{"title":"RSA","url":"/2025/12/15/RSA/","content":"\n# ***RSA***\n\nRSA算法是一种非对称加密算法，它依赖于大数因子分解的难度，通过一对密钥（公钥和私钥）来实现数据的加密和解密。RSA算法的核心是两个大质数的选择和一系列数学运算。\n密钥生成过程\n\nRSA算法的密钥生成过程涉及以下步骤：\n选择两个大质数 (p) 和 (q)，并计算它们的乘积 (N = p * q)，这个 (N) 将作为公钥和私钥的一部分。\n计算欧拉函数 (\\Phi(N) = (p-1) * (q-1))。\n选择一个整数 (e)，使得 (1 < e < \\Phi(N)) 且 (e) 与 (\\Phi(N)) 互质，这个 (e) 将作为公钥的另一部分。\n计算 (e) 的乘法逆元 (d)，使得 (d * e≡1(mod\\Phi(N)))，这个 (d) 将作为私钥。\n加密和解密过程\n\n加密和解密的数学表达式分别为：\n加密：(C = M^e \\mod N)\n解密：(M = C^d \\mod N)\n其中，(M) 是明文，(C) 是密文，(e) 和 (N) 组成公钥，(d) 和 (N) 组成私钥。\n数学证明\n\nRSA算法的正确性基于数学证明，其中涉及到欧拉定理和模运算的性质。证明的核心是展示加密后的密文通过解密可以得到原始的明文，即 (M^{ed} \\mod N = M)。\n实现示例\n\n以下是RSA算法的一个简化实现示例，展示了密钥生成、加密和解密的过程：\n```import random\nfrom sympy import isprime, mod_inverse\n```\n\n# 生成两个大质数p和q\n```def generate_large_prime():\nwhile True:\nnum = random.getrandbits(512)\nif isprime(num):\nreturn num\n\np = generate_large_prime()\nq = generate_large_prime()\n```\n\n# 计算N和Phi(N)\n```N = p * q\nPhi_N = (p - 1) * (q - 1)\n```\n\n# 选择e\n```e = random.randrange(1, Phi_N)\nwhile math.gcd(e, Phi_N) != 1:\ne = random.randrange(1, Phi_N)\n```\n\n# 计算d\n```\nd = mod_inverse(e, Phi_N)\n```\n\n# 公钥和私钥\n```public_key = (e, N)\nprivate_key = (d, N)\n```\n\n# 加密和解密函数\n```def encrypt(plaintext, public_key):\ne, N = public_key\nciphertext = [pow(ord(char), e, N) for char in plaintext]\nreturn ciphertext\n\ndef decrypt(ciphertext, private_key):\nd, N = private_key\nplaintext = ’‘.join([chr(pow(char, d, N)) for char in ciphertext])\nreturn plaintext\n```\n\n# 测试加密和解密\n```plaintext = ’Hello, RSA!‘\nciphertext = encrypt(plaintext, public_key)\ndecrypted_text = decrypt(ciphertext, private_key)\n\nprint(f’明文: {plaintext}‘)\nprint(f’加密后的密文: {ciphertext}‘)\nprint(f’解密后的明文: {decrypted_text}‘)\n```\n在这个示例中，我们首先生成了两个大质数 (p) 和 (q)，然后计算了 (N) 和 (\\Phi(N))。接着，我们选择了一个与 (\\Phi(N)) 互质的整数 (e) 作为公钥的一部分，并计算了 (e) 的乘法逆元 (d) 作为私钥。最后，我们定义了加密和解密函数，并对一个简单的明文进行了加密和解密操作。","tags":["Basics"],"categories":["Crypto"]},{"title":"Pyrdp-convert路径Errorsolve","url":"/2025/11/30/Pyrdp-convert路径ErrorSolve/","content":"\n# ***Pyrdp-convert路径ErrorSolve***\n\n\n### 1. 问题识别\n\n执行 pyrdp-convert rdp_dec.pcap -o out 命令时出现大量错误：\n\n```\n[-] Failed to handle data, continuing anyway: [Errno 2] No such file or \ndirectory: 'D_\\\\Forensicstools\\\\envs\\\\out\\\\20170823082818_192.168.43.\n185_59921-192.168.43.130_3389.pyrdp'\n```\n注意到路径中的 D: 被错误地替换为 D_ （冒号变成了下划线），导致系统无法找到正确的文件路径。\n\n### 2. 定位问题代码\n通过分析代码，我发现问题出在 d:\\Forensicstools\\envs\\pyrdp\\pyrdp\\recording\\recorder.py 文件中的 FileLayer 类：\n\n```\nself.filename = fileName\nself.filename = str(self.filename).replace(\":\", \"_\")  # 错误行：替换了所有冒号\n```\n这段代码将文件名中的 所有 冒号替换为下划线，包括 Windows 驱动器号中的冒号（如 D: ）。\n\n### 3. 修复方案\n我修改了代码，使其能够识别并保留 Windows 驱动器号中的冒号，同时替换文件名中其他位置的冒号：\n\n```\nself.filename = fileName\n# 保留 Windows 驱动器号中的冒号\nfilename_str = str(self.filename)\nif len(filename_str) > 1 and filename_str[1] == ':':\n    # 保留第一个冒号（驱动器号）\n    self.filename = filename_str[0:2] + filename_str[2:].replace(\":\", \"_\")\nelse:\n    # 对非 Windows 路径替换所有冒号\n    self.filename = filename_str.replace(\":\", \"_\")\n```\n### 4. 验证修复\n使用虚拟环境中的可执行文件测试修复后的命令：\n\n```\npyrdp-env\\Scripts\\pyrdp-convert.exe rdp_dec.pcap -o out\n```\n命令成功执行，生成了预期的输出文件：\n\n```\n[*] Analyzing PCAP 'rdp_dec.pcap' ...\n    - 192.168.43.185:59921 -> 192.168.43.130:3389 : plaintext\n[*] Processing 192.168.43.185:59921 -> 192.168.43.130:3389\n100% (1858 of 1858) || Elapsed Time: 0:00:00 Time:  0:00:00\n\n[+] Successfully wrote 'D:\\Forensicstools\\envs\\out\\20170823082818_192.168.\n43.185_59921-192.168.43.130_3389.pyrdp'\n```\n### 5. 修复效果\n从输出结果可以看到，路径中的驱动器号 D: 被正确保留，文件成功生成在指定的输出目录中。\n\n这个修复确保了 pyrdp-convert 工具能够在 Windows 系统上正确处理文件路径，同时保持对非 Windows 系统的兼容性。","tags":["Error"],"categories":["Error"]},{"title":"EzUSB","url":"/2025/11/30/EzUSB/","content":"\n# ***EzUSB***\n\n<from bugku>\n\n一个简单的USB流量\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251127100523716.png)\n\n点开第一个流量发现抓捕到payload,第三个字节为09.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251127100934440.png)\n\n表示USB Device向HOST发送了信息,“**Leftover Capture Data**” 就是 *USBPcap* 抓到的 EP 数据（payload）\n\n根据HID 键盘标准表:\n\n以下**kecode**对应的就是usage ID\n\n| Keycode |  键  | ASCII |\n| :-----: | :--: | :---: |\n|  0x04   |  a   |  61   |\n|  0x05   |  b   |  62   |\n|  0x06   |  c   |  63   |\n|  0x07   |  d   |  64   |\n|  0x08   |  e   |  65   |\n|  0x09   |  f   |  66   |\n|  0x0A   |  g   |  67   |\n|  0x0B   |  h   |  68   |\n|  0x0C   |  i   |  69   |\n|  0x0D   |  j   |  6A   |\n|  0x0E   |  k   |  6B   |\n|  0x0F   |  l   |  6C   |\n|  0x10   |  m   |  6D   |\n|  0x11   |  n   |  6E   |\n|  0x12   |  o   |  6F   |\n|  0x13   |  p   |  70   |\n|  0x14   |  q   |  71   |\n|  0x15   |  r   |  72   |\n|  0x16   |  s   |  73   |\n|  0x17   |  t   |  74   |\n|  0x18   |  u   |  75   |\n|  0x19   |  v   |  76   |\n|  0x1A   |  w   |  77   |\n|  0x1B   |  x   |  78   |\n|  0x1C   |  y   |  79   |\n|  0x1D   |  z   |  7A   |\n\n那么09对应的就是键盘上的  **f**\n\n其他的键对应的usage ID的表如下:\n\n###### ***数字:***\n\n| Keycode |  键  | 未按 Shift | 按下 Shift |\n| :-----: | :--: | :--------: | :--------: |\n|  0x1E   |  1   |    `1`     |    `!`     |\n|  0x1F   |  2   |    `2`     |    `@`     |\n|  0x20   |  3   |    `3`     |    `#`     |\n|  0x21   |  4   |    `4`     |    `$`     |\n|  0x22   |  5   |    `5`     |    `%`     |\n|  0x23   |  6   |    `6`     |    `^`     |\n|  0x24   |  7   |    `7`     |    `&`     |\n|  0x25   |  8   |    `8`     |    `*`     |\n|  0x26   |  9   |    `9`     |    `(`     |\n|  0x27   |  0   |    `0`     |    `)`     |\n\n###### ***控制键***\n\n| Keycode |   功能    |\n| :-----: | :-------: |\n|  0x28   |   Enter   |\n|  0x29   |    ESC    |\n|  0x2A   | Backspace |\n|  0x2B   |    Tab    |\n|  0x2C   |   Space   |\n\n###### ***符号键***\n\n| Keycode | 未按 Shift |    按下 Shift     |\n| :-----: | :--------: | :---------------: |\n|  0x2D   |    `-`     |        `_`        |\n|  0x2E   |    `=`     |        `+`        |\n|  0x2F   |    `[`     |        `{`        |\n|  0x30   |    `]`     |        `}`        |\n|  0x31   |    `\\`     |         `         |\n|  0x32   | `Non-US #` | `~`（因键盘而异） |\n|  0x33   |    `;`     |        `:`        |\n|  0x34   |    `'`     |        `\"`        |\n|  0x35   |    ```     |        `~`        |\n|  0x36   |    `,`     |        `<`        |\n|  0x37   |    `.`     |        `>`        |\n|  0x38   |    `/`     |        `?`        |\n\n###### ***功能键***\n\n| Keycode |  键  |\n| :-----: | :--: |\n|  0x3A   |  F1  |\n|  0x3B   |  F2  |\n|  0x3C   |  F3  |\n|  0x3D   |  F4  |\n|  0x3E   |  F5  |\n|  0x3F   |  F6  |\n|  0x40   |  F7  |\n|  0x41   |  F8  |\n|  0x42   |  F9  |\n|  0x43   | F10  |\n|  0x44   | F11  |\n|  0x45   | F12  |\n\n###### ***导航键***\n\n| Keycode |     键      |\n| :-----: | :---------: |\n|  0x4A   |    Home     |\n|  0x4B   |   PageUp    |\n|  0x4C   |   Delete    |\n|  0x4D   |     End     |\n|  0x4E   |  PageDown   |\n|  0x4F   | Right Arrow |\n|  0x50   | Left Arrow  |\n|  0x51   | Down Arrow  |\n|  0x52   |  Up Arrow   |\n\n###### ***小键盘***\n\n| Keycode |    键    |\n| :-----: | :------: |\n|  0x53   | Num Lock |\n|  0x54   |    /     |\n|  0x55   |    *     |\n|  0x56   |    -     |\n|  0x57   |    +     |\n|  0x58   |  Enter   |\n|  0x59   |    1     |\n|  0x5A   |    2     |\n|  0x5B   |    3     |\n|  0x5C   |    4     |\n|  0x5D   |    5     |\n|  0x5E   |    6     |\n|  0x5F   |    7     |\n|  0x60   |    8     |\n|  0x61   |    9     |\n|  0x62   |    0     |\n|  0x63   |    .     |\n\n回到那个***leftover capture data***\n\n```\n00 00 09 00 00 00 00 00\n```\n\n在 HID Boot Report 格式下，对数据 `00 00 09 00 00 00 00 00` 各字段的含义解析如下：\n\n- **字节 0（Modifier）：` 00`**：表示无修饰键被按下，即没有按下 Ctrl、Shift、Alt、GUI 等修饰键。\n- **字节 1（Reserved）：` 00`**：该字节为保留字节，在 HID Boot Report 格式中不做具体使用。\n- **字节 2（Keycode #1）：` 09`**：代表第一个被按下的键的 HID usage ID，也就是第一个按键的键码。\n- **字节 3 - 7（Keycode #2–#6）：` 00 00 00 00 00`**：表示除了第一个按键外，没有其他非修饰键被按下。\n\n我们再看一个:\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251127105448599.png)\n\n`Leftover Capture Data: 20002f0000000000` 是一组字节数据，按照常见的 HID 报告格式，可对其各字节含义进行如下解析：\n\n### 第 1 字节: 20\n\n将 `20` 转换为二进制是 `0010 0000`，这表示第 5 位被置 1，对应的是 Right Shift 键被按下。根据 HID 协议中修饰键位的定义，该字节用于表示修饰键的状态，所以此数据表明当前按下了 Right Shift 键 *1*。\n\n### 第 2 字节: 00\n\n通常该字节为保留字节，` 00` 表示此保留位无特殊含义。\n\n### 第 3 字节: 2f\n\n参考脚本中的映射关系，` 0x2F` 对应的字符是 `[`，所以该字节表示当前按下的按键对应的扫描码为 `[` 。\n\n### 第 4 - 8 字节: 00000000\n\n这几个字节通常用于表示其他按键，` 00` 表示当前没有其他额外的按键被按下。\n\n综合起来，`Leftover Capture Data: 20002f0000000000` 表示当前按下了 Right Shift 键和 `[` 键。\n\nRight Shift 键和 `[` 键这个组合键的对应的输入就是    **{**\n\n那么整个的就可以得到所有键入信息.\n\n最后可以使用  [青少年CTF在线工具箱](https://tools.qsnctf.com/#!)","tags":["CTF"],"categories":["Forensics"]},{"title":"UBIFS","url":"/2025/11/27/UBIFS及案例/","content":"\n**UBIFS**（Unsorted Block Image File System）是针对闪存设备设计的文件系统。我详细介绍一下UBIFS镜像的处理和分析：\n\n## UBIFS 概述\n\n### **特点**\n\n- 专为**原始闪存设备**设计\n- 支持**磨损均衡**、**坏块管理**\n- 提供**数据压缩**、**数据完整性**\n- 用于嵌入式Linux系统\n\n## UBIFS镜像结构\n\n### **镜像组成**\n\ntext\n\n```\nUBIFS镜像 → UBI卷 → UBIFS文件系统\n    ↓           ↓           ↓\n  .ubif文件  包含多个  实际文件系统\n             物理擦除块\n```\n\n\n\n### **层次结构**\n\ntext\n\n```\nRaw Flash\n    ↓\nMTD (Memory Technology Device) \n    ↓  \nUBI (Unsorted Block Images)\n    ↓\nUBIFS (File System)\n```\n\n\n\n## 处理UBIFS镜像的工具\n\n### **主要工具集**\n\nbash\n\n```\n# MTD工具\nmtdinfo, flash_erase, nandwrite\n\n# UBI工具  \nubinize, ubiformat, ubiattach\n\n# UBIFS工具\nmkfs.ubifs, ubirmvol, ubiupdatevol\n```\n\n\n\n## 镜像提取和分析步骤\n\n### **1. 识别镜像类型**\n\nbash\n\n```\n# 检查文件类型\nfile image.ubifs\nhexdump -C image.ubifs | head -20\n\n# 查找UBI魔术字\ngrep -a \"UBI#\" image.ubifs\n```\n\n\n\n### **2. 提取UBI卷**\n\nbash\n\n```\n# 使用ubinfo查看镜像信息\nubinfo --image image.ubifs\n\n# 挂载UBIFS镜像\nsudo modprobe nandsim first_id_byte=0xec second_id_byte=0xa1\nsudo modprobe ubi mtd=0\nsudo ubiformat /dev/mtd0 -f image.ubifs\nsudo ubiattach /dev/ubi_ctrl -m 0\nsudo mount -t ubifs ubi0:rootfs /mnt/ubifs\n```\n\n\n\n### **3. 直接解析UBIFS（无需硬件）**\n\nbash\n\n```\n# 使用ubireader提取文件\nubireader_extract_files -i image.ubifs -o extracted_files/\n\n# 使用ubidump分析结构\nubidump image.ubifs\n```\n\n\n\n## 使用UBI工具处理\n\n### **创建UBI镜像**\n\nbash\n\n```\n# 从目录创建UBIFS镜像\nmkfs.ubifs -r rootfs/ -m 2048 -e 126976 -c 1024 -o ubifs.img\n\n# 创建UBI镜像\nubinize -o image.ubifs -m 2048 -p 128KiB ubinize.cfg\n```\n\n\n\n### **ubinize配置文件示例**\n\nini\n\n```\n[ubifs]\nmode=ubi\nimage=ubifs.img\nvol_id=0\nvol_size=100MiB\nvol_type=dynamic\nvol_name=rootfs\nvol_flags=autoresize\n```\n\n\n\n## 编程方式处理UBIFS\n\n### **Python处理示例**\n\npython\n\n```\nimport subprocess\nimport os\n\ndef extract_ubifs(image_path, output_dir):\n    \"\"\"提取UBIFS镜像内容\"\"\"\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    \n    # 使用ubireader_extract_files\n    cmd = ['ubireader_extract_files', '-i', image_path, '-o', output_dir]\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    \n    if result.returncode == 0:\n        print(\"UBIFS镜像提取成功\")\n        return True\n    else:\n        print(f\"提取失败: {result.stderr}\")\n        return False\n\ndef analyze_ubifs_structure(image_path):\n    \"\"\"分析UBIFS结构\"\"\"\n    # 读取魔术字和基本信息\n    with open(image_path, 'rb') as f:\n        header = f.read(64)\n        \n    print(\"镜像头部信息:\")\n    print(f\"魔术字: {header[:4]}\")\n    print(f\"版本: {header[4:8]}\")\n    print(f\"数据偏移: {int.from_bytes(header[8:12], 'little')}\")\n```\n\n\n\n### **解析UBI头信息**\n\npython\n\n```\nimport struct\n\ndef parse_ubi_ec_hdr(data):\n    \"\"\"解析UBI EC头\"\"\"\n    magic = data[0:4]\n    version = data[4:8]\n    ec = struct.unpack('<I', data[8:12])[0]  # 擦除计数器\n    vid_hdr_offset = struct.unpack('<I', data[12:16])[0]\n    data_offset = struct.unpack('<I', data[16:20])[0]\n    \n    return {\n        'magic': magic,\n        'version': version,\n        'erase_counter': ec,\n        'vid_hdr_offset': vid_hdr_offset,\n        'data_offset': data_offset\n    }\n```\n\n\n\n## 在数字取证中的应用\n\n### **取证分析步骤**\n\nbash\n\n```\n# 1. 创建镜像副本\ndd if=/dev/mtd0 of=flash_dump.bin bs=1M\n\n# 2. 分析MTD分区\nmtdinfo flash_dump.bin\n\n# 3. 提取UBIFS内容\nubireader_extract_images -i flash_dump.bin -o extracted_volumes/\n\n# 4. 文件系统分析\nls -la extracted_volumes/\nfind extracted_volumes/ -name \"*.conf\" -o -name \"*.sh\"\n```\n\n\n\n### **重要数据位置**\n\nbash\n\n```\n# 配置文件\n/etc/passwd\n/etc/shadow\n/etc/network/interfaces\n\n# 日志文件\n/var/log/messages\n/var/log/auth.log\n\n# 用户数据\n/home/\n/root/\n/tmp/\n```\n\n\n\n## 常见问题解决\n\n### **1. 挂载失败**\n\nbash\n\n```\n# 错误: UBI device 0 not found\nsudo modprobe ubi\nsudo ubiattach /dev/ubi_ctrl -m 0 -d 0\n\n# 错误: Invalid argument\n# 检查PEB大小是否匹配\nubinfo --image image.ubifs\n```\n\n\n\n### **2. 镜像损坏**\n\nbash\n\n```\n# 尝试修复\nubirepair image.ubifs\n\n# 强制挂载\nsudo ubiformat /dev/mtd0 -f image.ubifs -s 2048\n```\n\n\n\n## 高级分析技巧\n\n### **恢复删除文件**\n\nbash\n\n```\n# UBIFS删除文件恢复较难，但可以尝试：\n# 1. 扫描原始镜像字符串\nstrings flash_dump.bin | grep -i \"password\"\n\n# 2. 分析未分配擦除块\nubireader_display -i image.ubifs\n```\n\n\n\n### **时间线分析**\n\nbash\n\n```\n# 提取文件时间信息\nfind extracted_volumes/ -type f -exec stat {} \\; > timeline.txt\n\n# 分析修改时间\ncat timeline.txt | grep \"Modify\"\n```\n\n\n\n## 实际案例\n\n### **路由器固件分析**\n\nbash\n\n```\n# 下载路由器固件\nwget http://example.com/firmware.bin\n\n# 提取UBIFS分区\nbinwalk -e firmware.bin\n\n# 分析提取的文件\ncd _firmware.bin.extracted/\nubireader_extract_files -i *.ubifs -o router_fs/\n```\n\n\n\n### **嵌入式设备取证**\n\npython\n\n```\n# 自动化分析脚本\nimport os\nimport hashlib\n\ndef analyze_embedded_device(image_path):\n    \"\"\"分析嵌入式设备镜像\"\"\"\n    print(\"=== UBIFS镜像分析报告 ===\")\n    \n    # 1. 基本信息\n    size = os.path.getsize(image_path)\n    print(f\"镜像大小: {size} bytes\")\n    \n    # 2. 提取文件\n    extract_dir = \"extracted_fs\"\n    if extract_ubifs(image_path, extract_dir):\n        # 3. 分析提取的文件\n        for root, dirs, files in os.walk(extract_dir):\n            for file in files:\n                filepath = os.path.join(root, file)\n                print(f\"找到文件: {filepath}\")\n```\n\n\n\n## 工具安装\n\n### **Ubuntu/Debian**\n\nbash\n\n```\nsudo apt update\nsudo apt install mtd-utils ubi-utils binwalk\n```\n\n\n\n### **CentOS/RHEL**\n\nbash\n\n```\nsudo yum install mtd-utils\n# 需要从源码编译ubi-utils\ngit clone https://github.com/oberhumer/ubi-utils\ncd ubi-utils && make\n```\n\n\n\n## 总结\n\n**UBIFS镜像分析关键点**：\n\n**使用正确的工具链**（mtd-utils, ubi-utils）\n**解层次结构**（MTD→UBI→UBIFS）\n**注意参数匹配**（PEB大小、块大小）\n\n**备份原始镜像**再进行操作\n\n使用ubi_reader（推荐）\nbash\n\n### 安装ubi_reader\nsudo apt install python3-pip\npip3 install ubi_reader\n\n### 提取UBI卷信息\nubinfo --image firmware.ubifs\n\n### 显示详细结构\nubireader_display -i firmware.ubifs\n\n### 提取所有文件\nubireader_extract_files -i firmware.ubifs -o extracted_fs/\n\n\n\n","tags":["Basics"],"categories":["Basics"]},{"title":"DNS Courier","url":"/2025/11/27/DNS Courier/","content":"\n# ***DNS Courier***\n\n*<from NSSCTF（CTF）>*  \n\n发现访问了多次奇怪的域名请求。\n\n过滤这类请求（自行想办法过滤）\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126163147555.png)\n\n然后将这类流量包提取打包成另一个pcapng文件（如果嫌原来的流量包分析起来慢的话）\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126163224605.png)\n\n可以发现按时间顺序排序的第一个域名请求包含504B0304，那么可以联想到作者将压缩包元数据作为域名请求了。\n\n然后我们自然而然想到提取这些数据还原压缩包。\n\n但是这里足足有20万条流量包，也就是最少需要20万行的批处理，这里有人说用代码跑，但是并不建议，我们先提取数据。\n\n因为已经过滤出了含有这些元数据的流量包，我们可以全选**（CTRL+A）**，进行提取。\n\n然后按图示操作复制为文本。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126163245257.png)\n\n以下就是得到的数据了，但是该怎么处理呢。\n\n我试过了很多种编辑器，VSC，Sub，notepad++（但是都由于选中数量有限，同时行不对齐而加剧了更多的工作量）。。。。。最后我决定用010editor进行对数据的整理和提取。以下是我用010editor进行数据整理提取的过程。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126163309208.png)\n\nOK足足有20多万行🙌\n\n我们进行处理，这里010editor的方便之处就在于其可以对任意区的数据进行选中(删除。。。）操作。图示：\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126163333037.png)\n\n按住CRTL然后拖动鼠标进行选中特定区域，当然这里的数据不止需要选中这一点（这里只做演示），实际处理后的数据应该是这样。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126163358305.png)\n\n全选复制后可以重新新建一个空白页。\n\n注意：这里是CTRL+SHIFT+V进行粘贴才会作为16进制数=数据被存储在左侧16进制数据段。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126163418753.png)\n\n点击HEX，就可以看到。然后再保存为zip文件即可。发现是一个加密的压缩包。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126163440439.png)\n\n接下来就到了吃💩环节,首先,这是一个明文攻击没问题,但不是png作为明文文件,而是pdf,有可能有人会想到未明文攻击,用bkcrack去爆破.\n\n但最后还是爆破不出来.\n\n我们一直有个疑惑:之前提取的压缩包元数据的整合,最后一行并没有用到,谁能想到那是pdf文件md5值.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126163829146.png)\n\n正确思路是根据md5值通过搜索引擎找到原文件.......\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126162154194.png)\n\n这里我访问的第一个平台网址来查询md5\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126162156690.png)\n\n发现和加密压缩包中的一致.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126162158695.png)![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126162159942.png)\n\n最后还是GOOGLE搜索引擎才拿到了md5一致的原文件.\n\n之后就是熟悉的配方熟悉的味道了.\n\n原文件压缩成压缩包进行明文攻击.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126162245302.png)\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126162242230.png)\n\n然后我们得到明文攻击后的加密压缩包的密码\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126162246964.png)\n\n然后是得到了一个二维码图片.\n\n用这个网站工具:[QRazyBox - QR Code Analysis and Recovery Toolkit](https://merri.cx/qrazybox/)\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126162310033.png)\n\n进行操作,具体功能ai获取\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126162249602.png)\n\nextract一下得到flag.    ***OVER***\n\n(●'◡'●)\n","tags":["CTF"],"categories":["Forensics"]},{"title":"攻防世界HITBGSEC CTF 2017 - arrdeepee (Misc)","url":"/2025/11/26/Misc-HITBGSEC CTF 2017-arrdeepee/","content":"\n# ***Arrdeepee***\n\n*<from GFSJ>*\n\n题目描述:\n\n我们某一个box被pwn了。在检查过程中，我们发现了一个叫mimikatz的东西，我们以前没有安装过，所以我们清除了，并且重新安装了box。但是，我们忘记备份我们的flag文件了。幸运的是，我们有一个攻击者网络流量捕获。你可以帮我们恢复出flag文件吗？\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126141149861.png)\n\n流量分析,废话不多说,直接开始.\n\n发现大量tls,同时还有较为罕见的rdp流量,没接触过,试试.\n\n我们知道rdp流量中 **TPKT 是 RDP 的传输封装层**,同时默认端口：**TCP 3389**, 这种情况下如果没有TPKT流量,就需要wireshark对协议进行解析:\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126145516901.png)\n\n将从59921端口发往3389端口的TCP协议解析为TPKT协议,就可以看到了.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126140244616.png)\n\n那这时我们看一下比较有嫌疑的RDP流量,发现其被TLS加密了,这时我们的目的就变成了寻找key.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126151315370.png)\n\n那么key就大概率出现在UDP流量包中了,根据协议分级统计,发现UDP占比还是很高的.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126151442300.png)\n\n我们追踪一下UDP的流量包.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126151518276.png)\n\n大致看一下,发现并不是常见文件,但是仔细观察不难发现tss,key等字样,查阅资料:\n\n```\nTSSEcKeySet10\n```\n\nTSSE = Terminal Services Security\n EcKeySet10 = KeySet 标识\n → **CredSSP / RDP 安全握手数据**\n\n```\nMicrosoft Strong Cryptographic Provider\n```\n\n这段 hex 属于 **CredSSP / NTLM / TLS over RDP** 流量中的 **ASN.1 编码结构**，常见于：\n\n###### ✔ RDP 握手\n\n###### ✔ NTLMSSP AUTH\n\n###### ✔ 公钥传递（Public Key Authentication）\n\n###### ✔ 加密提供程序标识（Crypto Provider Name）\n\n特别是：\n\n- `Microsoft Strong Cryptographic Provider` → Windows 默认加密提供器名称\n\n- `TSSEcKeySet10` → RDP/CredSSP 密钥交换结构\n\n  总的来说, 这无疑就是我们需要寻找的关键key所在文件.\n\n将这段数据完整dump下来.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126152301513.png)\n\n进一步分析,首先丢进随波逐流里看看.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126152428856.png)\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126153708468.png)\n\n\n\n1: Certificate in DER format (x509 v3), header length: 4, sequence length: 2376\n2: Certificate in DER format (x509 v3), header length: 4, sequence length: 1466\n3: Private key in DER format (PKCS header length: 4, sequence length: 860)\n\n✔ Binwalk 检测到：\n项\t类型\t格式\t长度说明\n1\t证书\tX.509 v3 DER\tSequence 2376 bytes\n2\t证书\tX.509 v3 DER\tSequence 1466 bytes\n3\t私钥\tPrivate Key (PKCS#1 / PKCS#8) DER\tSequence 860 bytes\n\n也就是说，文件里包含：\n\n🟦 两份证书（很可能是：服务器证书中间证书 or 客户端证书）       🟥 一份私钥\n\n那么显然我们需要将私钥提取,接下来开始提取工作.\n\n这里我们用openssl进行解密提取,\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126152913220.png)\n\n\n\n```\nopenssl pkcs12 -in data.bin -nocerts -nodes -out private.key\n```\n\nOpenSSL 提示：\n\n```\nEnter Import Password:\n```\n\n这里的密码说是题目描述中的mimikatz,输入之后即可拿到私钥文件.  (关于mimikatz会有另一文章介绍).\n\n私钥文件内容:\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126153803695.png)\n\n很明显是RSA私钥的标准格式.\n\n我们进行私钥解密加密流量协议.\n\n我这里直接用命令行对第七层进行解密出的.\n\n`tshark -r \"rdp.pcap\" -d \"tcp.port==3389,tls\" -o \"tls.keys_list:0.0.0.0,0,tpkt,private.key\" -o \"tpkt.tcp.port:3389\" -U \"OSI layer 7\" -F \"pcap\" -w \"rdp_dec.pcap\"`\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126154824142.png)\n\n解密成功!这里就可以看到大量RDP流了.\n\n之后的步骤我也没见过,总的就是重放一下中间人攻击,因为官方用的工具十年前的版本,无人问津了,包括会出现各种兼容性,库等等问题,所以这里求助大佬得知了一个工具------pyrdp\n\n具体想了解使用教程和原理的可以看看这个老外的一个教程:\n\n[PyRDP: Remote Desktop Protocol MITM for Purple Teamers - Black Hat Arsenal 2022](https://www.youtube.com/watch?v=cSJ4-gXiNv4&t=29s)\n\n接下来我们看一下我们的题目,即使是pyrdp这个工具在没有具体的教程的情况还是非常的难用.\n\n我们进行简单的一个命令对解密的流量包文件进行验证,如果没有解密成功就会报错unknown tls.\n\n```\npyrdp-convert rdp_dec.pcap -o out \n```\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126155822236.png)\n\n```\npyrdp-convert -f mp4 -o \"自定义输出路径\" \"解密的后的rdp流量包文件路径\"\n```\n\n这里我当时不太会使用导致直接用pyrdp-convert命令进行对rdp还原为mp4文件,但是仅仅还原视频文件没什么用,需要视频中的输入信息(即剪切板信息).\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126160120503.png)\n\n但是由于pyrdp的限制, pyrdp-player(可以UI图形化) 重放文件时,文件格式必须为pyrdp(如果不转换直接用player进行重放会出现内存报错),但是在转换时老是报错,无奈我这里只能使用mcp(trae)进行了对工具源码进行篡改(似乎也增添了一个扩展),使其可以被自动转换为pyrdp文件进行重放.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126161206779.png)\n\n可以看到转换成功,所以说在功能性的开发上,mcp还是具有很大的优势和解决问题的能力的.\n\n\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126161515026.png)\n\n这样的话就轻松多了,整个过程最复杂头疼的还是这个工具.\n\n之后就是一个base64加密了一个加密压缩包的元数据,逆向解密一下就行了,base64编码和压缩包密码都在剪切板的信息里了.\n\n接下来就一路到底拿到flag.\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126161745356.png)\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126161749134.png)![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126161752629.png)\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251126161805329.png)\n\n○( ＾皿＾)っHiahiahia…\n","tags":["CTF"],"categories":["Forensics"]},{"title":"VMware Linux Mouse Wheel Tuning and Smooth Scrolling","url":"/2025/11/09/VmwareLinuxmouseScrolling/","content":"\n# ***VMware Linux命令窗口鼠标滑轮体验优化解决方案***\n\n### 为什么 VMware 下鼠标滚轮手感差\n\n1. **虚拟机的输入延迟**：\n    VMware 把宿主机的鼠标输入“翻译”成虚拟信号发送到客机，滚轮事件分辨率很低（一次滚动往往是好几行）。\n\n2. **libinput 默认步长过大**：\n    Linux 桌面默认按“行”滚动，而不是“像素滚动”，导致特别跳。\n\n3. **没有加速度补偿**：\n    虚拟设备（如 `VirtualPS/2 VMMouse`）通常不支持高精度滚动（不像真实 USB 鼠标那样有分级信号）。\n\n   \n\n#### ***启用平滑滚动*（针对 GNOME / libinput）**\n\n在命令行执行：\n\n```\nsudo nano /etc/libinput/local-overrides.quirks\n```\n\n添加以下内容：\n\n```\n[VMware Virtual Mouse]\nMatchName=VMware VMware Virtual USB Mouse\nAttrScrollMethod=button\nAttrScrollPoints=1\n```\n\n然后重启或运行：\n\n```\nsudo udevadm control --reload-rules && sudo udevadm trigger\n```\n\n若出现报错\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251109222353816.png)\n\n这个提示说明：\n\n> 你的系统里还没有 `/etc/libinput/` 这个目录。\n\n不同的 Linux 发行版（特别是在虚拟机中）默认并不会创建这个文件夹。\n 解决很简单：\n\n------\n\n### 方法 ：先创建目录\n\n```\nsudo mkdir -p /etc/libinput\n```\n\n然后再执行：\n\n```\nsudo nano /etc/libinput/local-overrides.quirks\n```\n\n粘贴进去：\n\n```\n[VMware Virtual Mouse]          \nMatchName=VMware VMware Virtual USB Mouse   //“设备匹配规则”—— 指定这份配置只对 “名称为 VMware 虚拟 USB 鼠标” 的设备生效\nAttrScrollMethod=button                     //设置滚动方式为 “按钮模拟滚动”—— 把鼠标滚轮的 “行级触发”（默认一次滚多行）分成 “像素级触发”，是实现 “平滑滚动” 的核心；\nAttrScrollPoints=1                          //设置最小滚动步长为 1 个单位（接近像素级）—— 解决默认 “一次滚多行” 的跳变问题，让滚动更细腻。\n```\n\n\n\n保存（`Ctrl+O` → 回车 → `Ctrl+X` 退出），\n 再执行：\n\n```\nsudo udevadm control --reload-rules && sudo udevadm trigger    //udevadm 是 Linux 管理设备规则的工具\n                                                               //重新加载系统的设备规则（修改配置文件后，必须重载才能让 系统识别新规则）\n                                                               //触发设备规则生效（相当于 “刷新” 所有设备，让新配置立即\n应用到虚拟鼠标上）。\n```\n\n重启后生效。\n\n\n\n### ***使用 `imwheel` 设置滚轮加速***\n\n既然你已经有平滑滚动，可以让 `imwheel` 帮你加速快速滚动：\n\n```\nsudo apt install imwheel -y\n```\n\n然后创建配置：\n\n```\nnano ~/.imwheelrc             //  ~：代表当前用户的主目录（比如你的用户名是 user，路径就是 /home/user/）\n                              //  .imwheelrc：imwheel 的配置文件（文件名前加 . 表示 “隐藏文件”，专门存放个人的工具配置）\n```\n\n内容如下 👇：\n\n```\n\".*\"\nNone,      Up,   Button4, 5\nNone,      Down, Button5, 5\nControl_L, Up,   Button4, 10\nControl_L, Down, Button5, 10\nShift_L,   Up,   Button4, 2\nShift_L,   Down, Button5, 2\n```\n\n|             配置行             |         辅助键          |   滚轮方向   | 鼠标按键 | 滚动倍率 |                    实际效果（通俗理解）                     |\n| :----------------------------: | :---------------------: | :----------: | :------: | :------: | :---------------------------------------------------------: |\n|     `None, Up, Button4, 5`     |     None（无按键）      |  Up（上滚）  | Button4  |    5     | 日常默认滚动：滚一下相当于原来的 5 倍速度（平衡平滑与效率） |\n|    `None, Down, Button5, 5`    |     None（无按键）      | Down（下滚） | Button5  |    5     |                    同上，下滚的默认加速                     |\n|  `Control_L, Up, Button4, 10`  | Control_L（左 Ctrl 键） |  Up（上滚）  | Button4  |    10    |       按住 Ctrl + 上滚：快速滚动（适合长文档 / 网页）       |\n| `Control_L, Down, Button5, 10` | Control_L（左 Ctrl 键） | Down（下滚） | Button5  |    10    |                 按住 Ctrl + 下滚：快速下滚                  |\n|   `Shift_L, Up, Button4, 2`    | Shift_L（左 Shift 键）  |  Up（上滚）  | Button4  |    2     |     按住 Shift + 上滚：精细滚动（适合代码 / 表格对齐）      |\n|  `Shift_L, Down, Button5, 2`   | Shift_L（左 Shift 键）  | Down（下滚） | Button5  |    2     |                 按住 Shift + 下滚：精细下滚                 |\n\n保存退出后，运行：\n\n```\nimwheel -kill\n```\n\n你可以反复调最后那个数字（5）：\n\n- 越大 → 滚动速度更快（适合高分辨率屏幕）；\n- 越小 → 更自然。","tags":["Preferences"],"categories":["Preferences"]},{"title":"Block-chain Signln","url":"/2025/10/28/Blockchain  SignIn/","content":"\n# ***Block-chain  Signln***\n\n<from geekchallenge>\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251029163022356.png)\n\n题目给了我们区块hash，我们可以查询~***[TESTNET Sepolia (ETH) Blockchain Explorer](https://sepolia.etherscan.io/)***\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251029163110698.png)\n\n根据hash查询交易信息\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251029163114779.png)\n\n这里click to SHOW MORE\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251029163120495.png)\n\n发现一个INPUT DATA是hex转一下，得到flag。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251029163124653.png)\n\n☆*: .｡. o(≧▽≦)o .｡.:*☆《~☆~》*: .｡. o(≧▽≦)o .｡.:*☆ ","tags":["CTF"],"categories":["Blockchain"]},{"title":"traffic 1","url":"/2025/10/28/GFSJ_traffic1/","content":"# ***traffic 1***\n\n*<from Gfsj_misc_Traffic Analysis>*\n\n有tcp无http，怀疑tls\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103420190.png)\n\n过滤tls\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103424488.png)\n\n大量tlsv1.2协议。\n\n发现Encrypt字段，怀疑解密。\n\n搜索key没有发现，再看了看发现有ftp协议，看看什么模式。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103428217.png)\n\n不管了直接搜ftp-data协议（主动模式下无ftp-data数据包，被动模式有）\n\n传输了大量key.log文件\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103428217.png)\n\n追踪流。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103432448.png)\n\n每一行都以 `CLIENT_RANDOM` 开头，后面跟着两个长串的十六进制字符串。这是典型的 **TLS（传输层安全协议）密钥日志格式**，用于解密  加密流量。\n\n我们导出保存为key.log\n\n之后对加密流量包解密。进入***编辑 → 首选项 → 协议 → TLS***\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103436331.png)\n\n点击应用完成解密。如果解密不成功可以试试把debug file添加上。\n\n解密成功。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103439925.png)\n\n导出http。\n\n文件有点多，我们可以选择可疑的导出。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103443960.png)\n\n这里有个zip导出一下。发现是一个音频。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103448382.png)\n\n尾部有噪音。Audacity打开。\n\n频谱图看一下尾部。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103452336.png)\n\n发现是key不是flag，说明我们遗漏了什么东西。回头看看。\n\n不管了，这里直接binwalk+foremost一下。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103457987.png)\n\n分理出2个压缩包。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103503383.png)\n\n输入刚才的key\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103507403.png)\n\n得到flag：***flag{4sun0_y0zora_sh0ka1h@n_#>><<#}***\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030103512520.png)\n\n○( ＾皿＾)っHiahiahia…","tags":["CTF"],"categories":["Forensics"]},{"title":"evil_mcp","url":"/2025/10/28/evil_mcp/","content":"# ***evil_mcp***\n\n*<from geekchallenge>*\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030105202206.png)\n\n**ez_AI**：打开环境\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030105205382.png)\n\n*这里思路是编写一个脚本注入获取flag*\n\n```\nfrom typing import Any\n\n@tool(\n    name=\"get_flag\",\n    description=\"Get the flag from the server\",\n    input_schema={\n        \"type\": \"object\",\n        \"properties\": {},\n        \"required\": []\n    }\n)\nasync def get_flag(arguments: dict[str, Any], context: Any) -> Any:\n    \"\"\"Get the flag.\"\"\"\n    with open('/flag', 'r') as f:\n        content = f.read()\n    return content\n```\n\n粘贴进MCP工具代码框，保存并加载工具。\n\n最后get_flag就行。\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030105210043.png)\n\n☆*: .｡. o(≧▽≦)o .｡.:*☆喔耶!\n","tags":["CTF"],"categories":["AI"]},{"title":"ESP定律","url":"/2025/10/28/脱壳ESP（扩展栈指针）定律/","content":"# ***ESP（扩展栈指针）***\n\n***principle：***\n\n*在程序执行过程中，栈的操作与函数调用、局部变量存储等密切相关。当程序执行到某个函数调用时，会将函数的参数、返回地址等信息压入栈中，而 ESP 则始终指向栈顶。****X86 exp寄存器存储的是当前栈顶的内存地址。***\n\n***Function：***\n\nESP 定律的核心原理基于栈的平衡机制。在一些情况下，特别是在加密程序或存在代码保护机制的软件中，程序可能会对自身代码进行加密或混淆处理，使得直接分析原始代码变得困难。然而，**当程序执行到特定关键代码段（如解密后的代码部分）时，通常会涉及到栈的操作，导致 ESP 的值发生有规律的变化**。通过**监测 ESP 的值变化，我们可以找到这些关键代码的执行点**。\n\n***CPP：***\n\n```\n`#include <iostream>`\n\n`void encryptedFunction() {`\n`// 这里假设是一些加密后的代码逻辑`\n`std::cout << \"This is the encrypted part of the code.\" << std::endl;`\n`}`\n\n`int main() {`\n`// 调用加密函数前的栈状态`\n`int localVar1 = 10;`\n`int localVar2 = 20;`\n\n\nencryptedFunction();\n\n// 调用加密函数后的栈状态\nstd::cout << \"After the function call, localVar1: \" << localVar1 << \", localVar2: \" << localVar2 << std::endl;\n\nreturn 0;\n\n}\n```\n\n\n\n***个人理解（仅供参考）：***\n\n*ESP（扩展栈指针）*：对于调用函数等操作，在对关键代码进行定位查找的困难过程中，可以通过观察ESP的值进行对函数地址的定位，比如程序在调用**encryptedFunction**函数时，会涉及到栈的操作，导致 ESP 的值发生有规律的变化。通过监测 ESP 的值变化，我们可以找到这些关键代码的执行点。\n\n\n\n\n\n***Example：***\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104434071.png)\n\n\n\n**我创建了一个简单的PE文件，并对其进行基础加壳upx -d  project1.exe**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104438830.png)\n\n\n\n**接着对upx特征段进行篡改使其无法被基础脱壳掉。如下图**：\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104443152.png)\n\n\n\n\n\n**然后针对此类加壳我们可以用esp定律进行动态调试来完成脱壳。**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104446580.png)\n\n\n\n\n\n首先单步调试，发现ESP寄存器出大红（**ESP 寄存器变红表示栈指针（Stack Pointer）的值发生了异常或不一致，可能触发了栈平衡错误。**）\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104449794.png)\n\n\n\n\n\n**将内存窗口的显示定位到与该寄存器值相关的内存地址处，方便查看对应内存地址中的数据。**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104453237.png)\n\n\n\n\n\n**任意字符下硬件断点**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104456305.png)\n\n\n\n\n\n**run to line(jmp project.6c1023)，找到[OEP]（ 程序的入口点 ）**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104459583.png)\n\n\n\n\n\n**设置EIP，收工。**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104503551.png)\n\n\n\n\n\n**最后dump下来，检验一下。**\n\n![img](https://raw.githubusercontent.com/HuA-m1/Pic%20/main/pic/20251030104507280.png)\n\n**脱壳成功！**🙌🙌🙌","tags":["CTF"],"categories":["Reverse"]}]